




<!DOCTYPE html>
<html>
<head>
 <style>
    .action-buttons {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      margin-top: 10px;
    }

    .btn.claim {
  background: #2563eb; /* marketplace blue */
  color: #fff;
}

    .btn.open {
      background: #6b4eff;
      color: #fff;
    }
  </style>
</head>
  <!-- Xumm & XRPL SDKs -->
  <script src="https://xumm.app/assets/cdn/xumm.min.js"></script>


  <!-- BUILD TAG: CFC-OK -->
  <meta charset="utf-8"/><meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>Center for Creators ‚Äî CFC on XRPL</title>
<meta content="Center for Creators NFT site ‚Äî Faucet + Marketplace powered by CFC on XRPL." name="description"/>
 <meta property="og:title" content="Center for Creators NFT Marketplace" />
<meta property="og:description" content="Explore live NFTs, services, workshops, and digital books on XRPL." />
<meta property="og:image" content="https://centerforcreators.com/path-to-a-static-image.jpg" />
<meta property="og:url" content="https://centerforcreators.com/nft-marketplace" />
<meta property="og:type" content="website" />

<!-- Render-hosted SDKs (so gateways don't block) -->
<style>
    .divider{height:1px;background:var(--accent);opacity:0.6;margin:10px 0 14px 0;border-radius:999px}


    :root { --bg:#0b1220; --card:#121a2b; --text:#f6f8ff; --muted:#9fb0d1; --accent:#7db8ff; --ok:#1fcf7c; --warn:#ffcc00; --err:#ff6b6b;}
    *{box-sizing:border-box}
    html,body{margin:0;padding:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif}
    a{color:var(--accent);text-decoration:none}
   .wrap{
  max-width:1400px;
  margin:0 auto;
  padding:22px;
}
    header{display:flex;justify-content:space-between;align-items:center;gap:16px;margin-bottom:22px}
    .brand{display:flex;align-items:center;gap:12px}
    .brand img{width:44px;height:44px;border-radius:10px;display:block;background:#7c3aed}
    h1{font-size:20px;margin:0;line-height:1.2}
    .btn{background:var(--accent);color:#ffffff !important;padding:10px 14px;border-radius:10px;border:0;font-weight:700;cursor:pointer}
    .btn.secondary{background:#007bff !important;color:#ffffff !important}
    .btn.ghost{background:transparent;border:1px solid #2a3a60;color:var(--text)}
    .btn.small{padding:8px 10px;font-size:14px}
   .grid{
  display:grid;
  grid-template-columns:repeat(auto-fill,minmax(280px,1fr));
  gap:12px;
  max-width:1100px;
  margin:0 auto;
}
  /* FORCE consistent 3-column layout on desktop */
@media (min-width: 900px) {
  #purchasesGrid.grid,
  #cfc-market-grid.grid {
    grid-template-columns: repeat(3, minmax(280px, 1fr));
  }
}

  /* My Purchases should never stretch single items */
.purchases-grid {
  grid-template-columns: repeat(auto-fill, 280px);
  justify-content: start;
}

  /* Force identical spacing between Marketplace and My Purchases */
#cfc-market-grid.grid,
#purchasesGrid.grid {
  gap: 12px;
}
  /* Match Marketplace layout to My Purchases exactly */
#cfc-market-grid,
#purchasesGrid {
  max-width: 1100px;
  margin: 0 auto;
}

#cfc-market-grid.grid,
#purchasesGrid.grid {
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
}
    .card{background:var(--card);border:1px solid #202c45;border-radius:16px;padding:18px}
  /* Match Marketplace card behavior exactly */
.purchases-grid .card {
  width: 100%;
  max-width: 280px;
}

  /* Match live NFTs to static NFT card width */
.live-nft-card {
  max-width: none;
  width: 100%;
}
    .muted{color:var(--muted)}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
   /* Base NFT image styling (shared) */
.card .nft-img {
  width: 100%;
  height: 260px; /* ORIGINAL marketplace NFT size */
  object-fit: cover;
  border-radius: 12px;
  display: block;
}
  
    input[type="email"], input[type="text"]{width:100%;outline:none;padding:10px;border-radius:10px;border:1px solid #2a3a60;background:#0e1527;color:#e8f0ff}
    .kv{display:flex;gap:10px;align-items:center}
    .kv div:first-child{width:140px;color:#9fb0d1}
    footer{margin-top:30px;color:#9fb0d1;font-size:14px}
    .status{margin-top:8px;font-size:14px}
    .status.ok{color:var(--ok)} .status.warn{color:var(--warn)} .status.err{color:var(--err)}
    .toast{position:fixed;right:16px;bottom:16px;background:#132b1f;color:#caffa9;border:1px solid #1b5e2c;border-radius:12px;padding:12px 14px;display:none;z-index:9999}
    .spinner{display:none;width:16px;height:16px;border-radius:50%;border:3px solid #2a3a60;border-top-color:var(--accent);animation:spin 0.9s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
    /* ensure buttons clickable even in gateway viewer */
    #connectBtn,#claimBtn{pointer-events:auto;opacity:1}
    .captcha{display:flex;gap:8px;align-items:center}
    .captcha .tag{background:#1a2745;color:#cfe3ff;padding:4px 8px;border-radius:999px;font-size:12px}
    .note{font-size:12px;color:#9fb0d1;margin-top:6px}
   /* --- CFC BUTTON COLOR OVERRIDES --- */

  /* My Purchases = GREEN */
  .btn.my-purchases {
    background-color: #41b649 !important;
    border-color: #41b649 !important;
    color: #ffffff !important;
  }

  .btn.my-purchases:hover {
    background-color: #37a03f !important;
  }

  /* Redeem = ORANGE */
  .btn.redeem {
    background-color: #ff8c1a !important;
    border-color: #ff8c1a !important;
    color: #ffffff !important;
  }

  .btn.redeem:hover {
    background-color: #e67600 !important;
  }
 .btn.orange { background:#ff7a00; color:#ffffff !important; }
.btn.blue   { background:#007bff; color:#ffffff !important; }
.btn.green  { background:#28a745; color:#ffffff !important; }
.btn.yellow { background:#ffc107; color:#ffffff !important; }
.btn.purple { background:#6f42c1; color:#ffffff !important; }

.btn.active {
  box-shadow: inset 0 0 0 2px rgba(255,255,255,.6);
}
</style>
<script>
    // ------- CONFIG (single block) -------
    window.CONFIG = { USE_CORS_PROXY: true, CORS_PROXY: 'https://cors.isomorphic-git.org/', 
      FAUCET_ENDPOINT: 'https://cfc-faucet.onrender.com/api/faucet',
      faucetAmount: 25,
      currencyCode: 'CFC',
      issuer: 'rsxUkmjnAn8PRDz8RYrPusb9mTDYn5NqG8',
};
  </script>
<script>
    // Helpers
    function $(sel){ return document.querySelector(sel); }
    function show(el){ el.style.display='block'; }
    function hide(el){ el.style.display='none'; }
    function toast(msg){ const t=$('#toast'); t.textContent=msg; show(t); setTimeout(()=>hide(t), 3500); }
  </script>
<!-- Render-hosted SDKs -->
<script 
  onload="try{ window.xumm = new Xumm('eebd4c17-c3ef-435b-b891-89afb99e259e'); }catch(e){ console.error(e); }" 
  src="https://cfc-nft-marketplace-frontend.onrender.com/sdk/xumm.min.js">
</script>

<script src="https://cfc-nft-marketplace-frontend.onrender.com/sdk/xrpl-latest-min.js"></script>

<style>
  /* CFC-AUTO-STYLE */
  .server-waiting-url { display: none !important; }
</style>
<style>
  button { cursor: pointer !important; }
</style>

</head>
<body>
<div class="wrap">
<header>
<div class="brand">
</div>
<button class="btn" id="connectBtn" onclick="try{ if(window.connect){connect()} else if(window.xumm){xumm.authorize()} }catch(e){}"><span id="addrBadge" style="margin-left:8px;opacity:0.9"></span>Connect Xaman Wallet</button><div id="emailInput" ...>

    
</header>
<!-- Injected: row (account + balances) -->
<style>
  .walletbar{display:flex;gap:14px;align-items:center;margin:10px 0;padding:10px 12px;border:1px solid #202c45;border-radius:12px;background:#0f1729}
  .tag{background:#1a2745;color:#cfe3ff;padding:4px 8px;border-radius:999px;font-size:12px}
  #connectBtn,
#claimBtn,
#navMarket {
  background-color: #007bff !important;
  color: #ffffff !important;
}

</style>
<div class="walletbar" id="walletbar" style="display:none">
<span class="tag" id="wb_status">Not connected</span>
<span class="muted">Account:</span><span id="wb_account" style="font-family:monospace"></span>
<span class="muted">XRP:</span><span id="wb_xrp">‚Äî</span>
<span class="muted">CFC:</span><span id="wb_cfc">‚Äî</span>
<button class="btn small" id="wb_trust" style="display:none" type="button">Add CFC Trustline</button>
<span id="connectedAddress">Not connected</span></div>
 
<div class="card" id="faucetCard" style="margin-bottom:16px">
<div class="row" style="justify-content:space-between">
<div>
<div style="font-weight:1000;margin-bottom:6px;font-size:20px !important;color:#FF8C00 !important;">
  Daily CFC Faucet
</div>

<div class="muted">Claim <strong id="faucetAmount">25</strong> CFC once every 24 hours.</div>
</div>
<div class="tag" id="faucetStatus">Server: Waiting for URL</div>
</div>
<div class="row" id="cfc-captcha-row" style="margin-top:12px">
<div class="row" style="margin-top:10px">
<button class="btn" id="claimBtn">Claim CFC</button>

<div class="spinner" id="claimSpin" style="display:none"></div>
<div class="status" id="claimStatus"></div>
</div>
<div class="muted" id="claimMsg" style="margin-top:8px"></div>
</div>


<div class="divider"></div>
<!-- Tokenization Header Section -->
<div class="nft-header" style="text-align:center; margin:25px 0;">
  <h1 style="font-size:28px; font-weight:800; color:#fff; margin-bottom:8px;">
    Tokenization That Empowers Your Purpose
  </h1>
  <p style="color:#9fb0d1; font-size:17px; max-width:650px; margin:0 auto;">
    From personal growth to blockchain strategy, every experience on Center for Creators 
    helps you learn, evolve, and earn CFC rewards.
  </p>
</div>

<div class="row" style="margin-bottom:12px">
  <button class="btn" id="navMarket">Marketplace</button>
  <button class="btn my-purchases" id="navPurchases">My Purchases</button>
  <button class="btn redeem" id="navRedeem">Redeem</button>
</div>
<script>
document.getElementById('navMarket').addEventListener('click', () => {
  // Reset category state
  activeCategory = "all";

  // Reset active tab UI
  document.querySelectorAll("#cfc-category-tabs .btn").forEach(b => b.classList.remove("active"));
  const allBtn = document.querySelector('#cfc-category-tabs [data-cat="all"]');
  if (allBtn) allBtn.classList.add("active");

  // Switch view + re-render
  if (typeof switchView === 'function') {
    switchView('market');
  }
  renderFilteredNFTs();
});
</script>

  <!-- LIVE MINTED NFT MARKET FEED (DYNAMIC) -->
<section id="cfc-market-live" style="padding:40px 0 10px 0;">
  
<h2 style="text-align:center;color:#fff;margin-bottom:20px;">
  Live NFTs from CFC Creators
</h2>

<!-- CATEGORY FILTER TABS -->
<div id="cfc-category-tabs" class="row" style="justify-content:center;margin-bottom:25px;gap:10px;">
  <button class="btn purple active" data-cat="all">All</button>
  <button class="btn orange" data-cat="services">Services</button>
  <button class="btn blue" data-cat="workshops">Workshops</button>
  <button class="btn green" data-cat="books">Books</button>
  <button class="btn yellow" data-cat="art">Art</button>
</div>
<script>
document.querySelectorAll('#cfc-category-tabs button').forEach(btn => {
  btn.addEventListener('click', () => {
    if (typeof switchView === 'function') {
      switchView('market');
    }
  });
});
</script>

<div id="cfc-market-grid" class="grid">
  <!-- Filled by JavaScript -->
</div>

</section>
<!-- STATIC NFT SECTION TEMPORARILY HIDDEN -->
<section id="view-market" style="display:none">
  <div class="grid">

    <!-- Service NFT -->
    <div class="card">
      <img alt="Service NFT image" class="nft-img" src="data:image/svg+xml;utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1024' height='576' viewBox='0 0 1024 576'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0' y1='0' x2='1' y2='1'%3E%3Cstop offset='0%25' stop-color='%237c3aed'/%3E%3Cstop offset='100%25' stop-color='%2322d3ee'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='1024' height='576' fill='url(%23g)'/%3E%3Ctext x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' font-family='Inter,Segoe UI,Arial,sans-serif' font-size='60' font-weight='700' fill='%23fff'%3EService NFT ‚Äî 1:1 Session%3C/text%3E%3C/svg%3E"/>

      <h3 style="margin:12px 0 6px">Unlock a 60-minute session with Christie Russ.</h3>
      <div class="muted" style="margin-bottom:12px">Learn and Earn. Proof of ownership on XRPL. Transferable prior to redemption.</div>

      <div class="row" style="justify-content:space-between">
        <div class="price-col">
          <div class="muted">Price</div>
          <div id="price1rlusd"><strong>500 RLUSD</strong></div>
          <div class="muted">¬∑</div>
          <div id="price1xrp"><strong>219 XRP</strong></div>
        </div>
        <div class="row">
          <button class="btn small" id="buy1rlusd">Pay in RLUSD</button>
          <button class="btn small secondary" id="buy1xrp">Pay in XRP</button>
        </div>
      </div>
    </div>

    <!-- Blockchain Made Simple NFT -->
    <div class="card">
      <img alt="Blockchain Made Simple NFT" class="nft-img" src="data:image/svg+xml;utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1024' height='576' viewBox='0 0 1024 576'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0' y1='0' x2='1' y2='1'%3E%3Cstop offset='0%25' stop-color='%2316a34a'/%3E%3Cstop offset='100%25' stop-color='%2384cc16'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='1024' height='576' fill='url(%23g)'/%3E%3Ctext x='50%25' y='46%25' dominant-baseline='middle' text-anchor='middle' font-family='Inter,Segoe UI,Arial,sans-serif' font-size='60' font-weight='700' fill='%23fff'%3EBlockchain Made Simple NFT%3C/text%3E%3Ctext x='50%25' y='54%25' dominant-baseline='middle' text-anchor='middle' font-family='Inter,Segoe UI,Arial,sans-serif' font-size='56' font-weight='600' fill='%23fff'%3EAmazon %231 Best Seller%3C/text%3E%3C/svg%3E" />

      <h3 style="margin:12px 0 6px">Blockchain Made Simple NFT</h3>
      <div class="muted" style="margin-bottom:12px">Read and Earn CFC Tokens. Limited edition NFT Book linked to bonus content.</div>

      <div class="row" style="justify-content:space-between">
        <div class="price-col">
          <div class="muted">Price</div>
          <div id="price2rlusd"><strong>35 RLUSD</strong></div>
          <div class="muted">¬∑</div>
          <div id="price2xrp"><strong>35 XRP</strong></div>
        </div>
        <div class="row">
          <button class="btn small" id="buy2rlusd">Pay in RLUSD</button>
          <button class="btn small secondary" id="buy2xrp">Pay in XRP</button>
        </div>
      </div>
    </div>

    <!-- The Power to Rise NFT -->
    <div class="card">
      <img alt="The Power to Rise NFT" class="nft-img" src="data:image/svg+xml;utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1024' height='576' viewBox='0 0 1024 576'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0' y1='0' x2='1' y2='1'%3E%3Cstop offset='0%25' stop-color='%23f59e0b'/%3E%3Cstop offset='100%25' stop-color='%23f97316'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='1024' height='576' fill='url(%23g)'/%3E%3Ctext x='50%25' y='45%25' dominant-baseline='middle' text-anchor='middle' font-family='Inter,Segoe UI,Arial,sans-serif' font-size='60' font-weight='700' fill='%23fff'%3EThe Power to Rise NFT%3C/text%3E%3Ctext x='50%25' y='55%25' dominant-baseline='middle' text-anchor='middle' font-family='Inter,Segoe UI,Arial,sans-serif' font-size='56' font-weight='600' fill='%23fff'%3EAmazon %231 Best Seller%3C/text%3E%3C/svg%3E" />

      <h3 style="margin:12px 0 6px">The Power to Rise NFT</h3>
      <div class="muted" style="margin-bottom:12px">Read and Earn CFC Tokens. Limited edition NFT Book linked to bonus content.</div>

      <div class="row" style="justify-content:space-between">
        <div class="price-col">
          <div class="muted">Price</div>
          <div id="price3rlusd"><strong>25 RLUSD</strong></div>
          <div class="muted">¬∑</div>
          <div id="price3xrp"><strong>11 XRP</strong></div>
        </div>
        <div class="row">
          <button class="btn small" id="buy3rlusd">Pay in RLUSD</button>
          <button class="btn small secondary" id="buy3xrp">Pay in XRP</button>
        </div>
      </div>
    </div>

  </div> <!-- ‚úÖ closes the grid -->
</section>
  <!-- END STATIC NFT SECTION -->

<section id="view-purchases" style="display:none">
  <div id="noPurchasesMsg" class="muted" style="text-align:center; margin:40px 0;">
    You don‚Äôt have any purchases yet.
  </div>
<div class="muted" id="purchasesTip" style="text-align:center; margin:0 0 14px 0; display:none;">
  Tip: After you redeem a book/workshop, click ‚ÄúOpen Content‚Äù to read and earn CFC.
</div>
<script>
function openReader(metadataCid, submissionId){
  if (!window.connectedAccount){
    alert("Connect your wallet first.");
    return;
  }

  const url =
    "https://centerforcreators.github.io/cfc-nft-marketplace-frontend/reader.html" +
    "?metadata_cid=" + encodeURIComponent(metadataCid) +
    "&submission_id=" + encodeURIComponent(submissionId) +
    "&wallet=" + encodeURIComponent(window.connectedAccount);

  window.open(url, "_blank");
}
</script>

<div class="grid purchases-grid" id="purchasesGrid" style="display:none; justify-items:center;"></div>
 
</section>

<section id="view-redeem" style="display:none">
  <div id="noRedeemMsg" class="muted" style="text-align:center; margin:40px 0;">
    You don‚Äôt have anything to redeem yet.
  </div>

  <input type="hidden" id="redeemOrderId">
</section>

</section>
<script>
document.getElementById('emailSubmit').addEventListener('click', () => {
  const email = document.getElementById('emailInput').value.trim()
  const box = document.getElementById('emailMsg')
  if(!/.+@.+\..+/.test(email)){
    box.textContent = 'Please enter a valid email.'
    return
  }
  const u = new URL(CONFIG.EMAIL_FALLBACK_URL)
  u.searchParams.set('email', email)
  window.open(u.toString(), '_blank')
  box.textContent = 'Opening contact page‚Ä¶'
})
  </script>
<script>
document.addEventListener('DOMContentLoaded', () => {

  const connectBtn = document.getElementById('connectBtn')
  if (connectBtn) connectBtn.addEventListener('click', connectXaman)

  const buy1rlusd = document.getElementById('buy1rlusd')
  if (buy1rlusd) buy1rlusd.addEventListener('click', () => buyWithRLUSD(CONFIG.ITEMS[0]))

  const buy2rlusd = document.getElementById('buy2rlusd')
  if (buy2rlusd) buy2rlusd.addEventListener('click', () => buyWithRLUSD(CONFIG.ITEMS[1]))

  const buy3rlusd = document.getElementById('buy3rlusd')
  if (buy3rlusd) buy3rlusd.addEventListener('click', () => buyWithRLUSD(CONFIG.ITEMS[2]))

  const buy1xrp = document.getElementById('buy1xrp')
  if (buy1xrp) buy1xrp.addEventListener('click', () => buyWithXRP(CONFIG.ITEMS[0]))

  const buy2xrp = document.getElementById('buy2xrp')
  if (buy2xrp) buy2xrp.addEventListener('click', () => buyWithXRP(CONFIG.ITEMS[1]))

  const buy3xrp = document.getElementById('buy3xrp')
  if (buy3xrp) buy3xrp.addEventListener('click', () => buyWithXRP(CONFIG.ITEMS[2]))


  if (typeof switchView === 'function') {
    switchView('market')
  }

})
</script>

<script>
document.addEventListener('DOMContentLoaded', function(){
  try {
    if (typeof newCaptcha !== 'function') {
      window._a=0;window._b=0;
      window.newCaptcha=function(){
        _a=Math.floor(Math.random()*10);_b=Math.floor(Math.random()*10);
        var A=document.getElementById('numA'),B=document.getElementById('numB');
        if(A)A.textContent=_a;if(B)B.textContent=_b;
        var I=document.getElementById('captchaInput'); if(I) I.value='';
      };
    }
    const cb=document.getElementById('connectBtn');
    if (cb && !cb.__bound){
      cb.addEventListener('click', function(){
        if (window.connect) return window.connect();
        if (window.connectXumm) return window.connectXumm();
        if (window.authorize) return window.authorize();
        if (window.xumm && xumm.authorize) return xumm.authorize();
      });
      cb.__bound=true;
    }
    const qb=document.getElementById('claimBtn');
    if (qb && !qb.__bound){
      qb.addEventListener('click', function(){
        if (window.claimFaucet) return window.claimFaucet();
        if (window.claim) return window.claim();
      });
      qb.__bound=true;
    }
    if (document.getElementById('numA') || document.getElementById('captchaInput')) newCaptcha();
  } catch(e){}
});
</script>
<style>
 #cfc-cap-ovl {
  display: none !important;
} 
#cfc-cap-ovl{position:fixed;inset:0;background:rgba(0,0,0,.55);display:none;z-index:9999}
#cfc-cap-card{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:#121a2b;color:#f6f8ff;
  border:1px solid #202c45;border-radius:14px;padding:16px;min-width:280px;box-shadow:0 10px 30px rgba(0,0,0,.4)}
#cfc-cap-card .row{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
#cfc-cap-card input{padding:8px;border-radius:8px;border:1px solid #2a3a60;background:#0e1527;color:#fff;width:90px}
#cfc-cap-actions{margin-top:12px;display:flex;gap:8px;justify-content:flex-end}
#cfc-cap-actions button{background:#7db8ff;color:#001428;border:0;border-radius:10px;padding:8px 12px;cursor:pointer;font-weight:700}
#cfc-cap-err{color:#ffb4b4;margin-top:6px;min-height:18px;font-size:14px}
</style>
<div aria-modal="true" id="cfc-cap-ovl" role="dialog">
<div id="cfc-cap-card">
<div style="font-weight:700;margin-bottom:8px">Quick check</div>
<div class="row">
<div id="cfc-cap-err"></div>
<div id="cfc-cap-actions">
<button id="cfcCancel" type="button">Cancel</button>
<button id="cfcOk" type="button">Confirm</button>
</div>
</div>
</div>
<script>
(function(){
  function rand(){ return Math.floor(Math.random()*10); } // 0..9
  function regen(){ window.__cfcA=rand(); window.__cfcB=rand();
    var A=document.getElementById('cfcA'), B=document.getElementById('cfcB'), I=document.getElementById('cfcAns');
    if(A) A.textContent=__cfcA; if(B) B.textContent=__cfcB; if(I) I.value='';
    var E=document.getElementById('cfc-cap-err'); if(E) E.textContent='';
  }
  window.cfcOpenCaptcha = function(){ var o=document.getElementById('cfc-cap-ovl'); if(o){ regen(); o.style.display='block'; } };
  function hide(){ var o=document.getElementById('cfc-cap-ovl'); if(o) o.style.display='none'; }

  document.addEventListener('DOMContentLoaded', function(){
    var ok=document.getElementById('cfcOk');
    var cancel=document.getElementById('cfcCancel');
    if(ok){
      ok.addEventListener('click', function(){
        var I=document.getElementById('cfcAns'); var E=document.getElementById('cfc-cap-err');
        var val=parseInt((I&&I.value)||'',10);
        if(isNaN(val) || val !== (__cfcA+__cfcB)){ if(E) E.textContent='Wrong answer ‚Äî try again.'; regen(); return; }
        window.__cfcCaptchaPassed = true;
        hide();
        try{ if (window.claimFaucet) return window.claimFaucet(); if (window.claim) return window.claim(); }catch(e){}
      });
    }
    if(cancel){ cancel.addEventListener('click', hide); }
  });
})();
</script>
<script>
window.CFC = window.CFC||{};

async function connect(){
  try{
    const res = await xumm.authorize();
    if (res?.me?.account){
      window.connectedAccount = res.me.account;
      sessionStorage.setItem('connectedAccount', res.me.account);
      var a=document.getElementById('address'); if(a) a.textContent = res.me.account;
      var m=document.getElementById('claimMsg'); if(m) m.textContent='';
    }
  }catch(e){ var m=document.getElementById('claimMsg'); if(m) m.textContent='Connection cancelled.'; }
}


    const signin = await xumm.payload.createAndSubscribe({ txjson: { TransactionType: 'SignIn' } }, () => {});
    if (signin?.created?.next) window.open(signin.created.next.always, '_blank');
    const res = await signin.resolved;
    if (!res?.signed || !res?.response?.account){ var m=document.getElementById('claimMsg'); if(m) m.textContent='Claim cancelled.'; if(spinner) spinner.style.display='none'; return; }
    if (res.response.account !== window.connectedAccount){ var m=document.getElementById('claimMsg'); if(m) m.textContent='Use the same wallet you connected.'; if(spinner) spinner.style.display='none'; return; }
    const r = await fetch(CONFIG.FAUCET_ENDPOINT, {
      method:'POST', headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ payload_uuid: signin.created.uuid, address: window.connectedAccount })
    });
    const data = await r.json().catch(()=>({}));
    var m=document.getElementById('claimMsg');
    if (r.ok) m && (m.textContent='‚úÖ 25 CFC sent! Check your wallet soon.');
   else if (m) {
  m.textContent = data?.error || 'Claim failed.';
  setTimeout(()=>{ m.textContent=''; },5000);
}
  }catch(e){ var m=document.getElementById('claimMsg'); if(m) m.textContent='Network error.'; }
  if(spinner) spinner.style.display='none';
  window.__cfcCaptchaPassed=false;
}
</script>
<script>
// Simple math CAPTCHA: digits 0‚Äì9, refresh each time
let _a = 0, _b = 0;
function newCaptcha(){
  _a = Math.floor(Math.random()*10);
  _b = Math.floor(Math.random()*10);
  const A = document.getElementById('numA'), B = document.getElementById('numB');
  if (A) A.textContent = _a;
  if (B) B.textContent = _b;
  const I = document.getElementById('captchaInput');
  if (I) I.value = '';
}
function checkCaptcha(){
  const I = document.getElementById('captchaInput');
  if (!I) return true; // if no UI, skip
  const val = parseInt(I.value,10);
  return !isNaN(val) && (val === (_a + _b));
}
// Initialize captcha when faucet view is shown
(function(){
  // If faucet is the default hidden view, call on DOM ready and when tab switches
  document.addEventListener('DOMContentLoaded', function(){
    try { newCaptcha(); } catch(e){}
  });
  window.addEventListener('hashchange', function(){ try { newCaptcha(); } catch(e){} });
})();
</script>
<script>
(function(){
  // Math captcha
  let _a=0,_b=0; function rnd(){return Math.floor(Math.random()*10)}
  window.regenCaptcha = window.regenCaptcha || function(){
    _a=rnd(); _b=rnd();
    var A=document.getElementById('capA'); if(A) A.textContent=_a;
    var B=document.getElementById('capB'); if(B) B.textContent=_b;
    var I=document.getElementById('capAns'); if(I) I.value='';
  };
  document.addEventListener('DOMContentLoaded', regenCaptcha);

  // Core actions
  async function _connect(){
    try{
      if (typeof Xumm==='undefined' || !window.xumm){ alert('Wallet SDK loading, try again.'); return; }
      const res = await xumm.authorize();
      if (res?.me?.account){
        var acct=document.getElementById('acct'); if(acct) acct.textContent=res.me.account;
        alert('Wallet connected');
      }else{
        alert('Connection cancelled');
      }
    }catch(e){ console.error(e); alert('Could not connect'); }
  }
 
      if(!r.ok) throw new Error('Faucet error');
      alert('‚úÖ 25 CFC sent!');
      regenCaptcha();
    }catch(e){ console.error(e); alert('Faucet request failed'); }
  }

  // Force-bind by ID
  function tryBind(id, fn){
    var el=document.getElementById(id);
    if (el && !el.onclick) el.onclick = fn;
  }
  tryBind('connectBtn', _connect);
  tryBind('claimBtn', _claim);

  // Fallback: bind by button text if IDs differ
  function bindByText(txt, fn){
    var btns=[...document.querySelectorAll('button')];
    btns.forEach(b=>{
      var t=(b.textContent||'').toLowerCase();
      if (t.includes(txt) && !b.onclick){ b.onclick = fn; }
    });
  }
  bindByText('connect xaman', _connect);
  bindByText('connect wallet', _connect);
  bindByText('claim', _claim);
})();
</script>
<script>
(function(){
  function alias(from, to){
    try{
      if (typeof window[from]==='function' && typeof window[to] !== 'function'){ window[to]=window[from]; }
      else if (typeof window[to]==='function' && typeof window[from] !== 'function'){ window[from]=window[to]; }
    }catch(e){}
  }
  document.addEventListener('DOMContentLoaded', function(){
    alias('onConnect','connectWallet');
    alias('onClaim','handleClaim');
    var cb=document.getElementById('connectBtn'); if(cb && !cb.onclick) cb.onclick = (window.connectWallet||window.onConnect);
    var cl=document.getElementById('claimBtn');   if(cl && !cl.onclick) cl.onclick   = (window.handleClaim||window.onClaim);
  });
})();
</script>
<script>
async function payXRP(nftId) {
  const r = await fetch(
    "https://cfc-nft-shared-mint-backend.onrender.com/api/market/pay-xrp",
    {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ id: nftId })
    }
  );

  const data = await r.json();
  if (data.link) {
    window.location.href = data.link;
  } else {
    alert("Payment failed");
  }
}

async function payRLUSD(nftId) {
  const r = await fetch(
    "https://cfc-nft-shared-mint-backend.onrender.com/api/market/pay-rlusd",
    {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ id: nftId })
    }
  );

  const data = await r.json();
  if (data.link) {
    window.location.href = data.link;
  } else {
    alert("Payment failed");
  }
}
</script>

<script>
    (function(){
      function bind(id, fn){
        var el = document.getElementById(id);
        if (el && !el.__bound){ el.__bound = true; el.addEventListener('click', function(ev){ ev.preventDefault(); fn(); }); }
      }

     // ---- begin safe init (keeps wallet + claim working, no regressions) ----
// Run wallet/core init immediately if your site defines it.
if (typeof boot === 'function') {
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', boot);
  } else {
    boot();
  }
}
// Delay ONLY the payment button wiring to help Chrome finish loading SDKs.
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => setTimeout(bindAll, 500));
} else {
  setTimeout(bindAll, 500);
}
try {
  new MutationObserver(() => setTimeout(bindAll, 500))
    .observe(document.documentElement, { childList: true, subtree: true });
} catch(e) {}
})();
// ---- end safe init ----
  </script>
<script>
    (function(){
      const form = document.getElementById('joinForm');
      if (!form) return;
      const emailEl = document.getElementById('joinEmail');
      const statusEl = document.getElementById('joinStatus');
      form.addEventListener('submit', async function(ev){
        ev.preventDefault();
        const email = (emailEl.value || '').trim();
        if(!email){ return; }
        statusEl.className='status warn'; statusEl.textContent='Submitting‚Ä¶';
        try{
          const res = await fetch((CONFIG && CONFIG.USE_CORS_PROXY ? (CONFIG.CORS_PROXY + 'https://cfc-faucet.onrender.com/api/join') : 'https://cfc-faucet.onrender.com/api/join'), {
            method:'POST', headers:{'Content-Type':'application/json'},
            body: JSON.stringify({ email })
          });
          const j = await res.json();
          if (j && j.ok){
            statusEl.className='status ok'; statusEl.textContent='üéâ You‚Äôre in!';
            emailEl.value='';
          } else {
            statusEl.className='status err'; statusEl.textContent=(j && j.error) || 'Join failed';
          }
        }catch(e){
          statusEl.className='status err'; statusEl.textContent='Network error';
        }
      });
    })();
  </script>
  <script>
if (!window.connectedAccount) {
  const saved = sessionStorage.getItem('connectedAccount');
  if (saved) {
    window.connectedAccount = saved;
  }
}
</script>
<section class="card" id="join">
<h2>Join the list</h2>
<p class="muted">Get updates from CenterForCreators.com</p>
<div style="max-width:420px">
<form class="row" id="joinForm" onsubmit="return false;">
<input id="joinEmail" placeholder="you@example.com" required="" type="email"/>
<button class="btn" id="joinBtn" type="submit">Join</button>
</form>
<div class="status" id="joinStatus"></div>
</div>
</section>
<script>
(function(){
  function gid(id){ return document.getElementById(id); }
  
  CONFIG.FAUCET_ENDPOINT = CONFIG.FAUCET_ENDPOINT || 'https://cfc-faucet.onrender.com/api/faucet';
  CONFIG.JOIN_ENDPOINT   = CONFIG.JOIN_ENDPOINT   || 'https://cfc-faucet.onrender.com/api/join';
  CONFIG.PAY_CFC_URL     = CONFIG.PAY_CFC_URL     || 'https://cfc-faucet.onrender.com/api/pay-cfc';
  CONFIG.PAY_XRP_URL     = CONFIG.PAY_XRP_URL     || 'https://cfc-faucet.onrender.com/api/pay-xrp';
  CONFIG.CFC_CURRENCY    = CONFIG.CFC_CURRENCY    || 'CFC';
  CONFIG.CFC_ISSUER      = CONFIG.CFC_ISSUER      || '';
  CONFIG.XRPL_WSS        = CONFIG.XRPL_WSS        || 'wss://xrplcluster.com';

  let account = localStorage.getItem('xrpl_account') || '';
  let connected = false;

  const bar = gid('walletbar'), st = gid('wb_status'), wa = gid('wb_account'), wx = gid('wb_xrp'), wc = gid('wb_cfc'), wtrust = gid('wb_trust');
  function showBar(){ if(bar) bar.style.display='flex'; }
  function setStatus(t){ if(st){ st.textContent=t; } }
  function setAccount(a){ if(wa){ wa.textContent = a||'‚Äî'; } }
  function setXrp(v){ if(wx){ wx.textContent = v; } }
  function setCfc(v){ if(wc){ wc.textContent = v; } }

  async function connectXRPLAndLoadBalances(acct){
    try{
      if(!window.xrpl){ console.warn('XRPL SDK not ready'); return; }
      const client = new xrpl.Client(CONFIG.XRPL_WSS);
      await client.connect();
      try{
        const ai = await client.request({ command:'account_info', account: acct, ledger_index:'validated' });
        const xrp = (ai.result.account_data.Balance/1000000).toFixed(6);
        setXrp(xrp);
      }catch(e){ setXrp('‚Äî'); }
      if(CONFIG.CFC_ISSUER){
        try{
          const al = await client.request({ command:'account_lines', account: acct, ledger_index:'validated', peer: CONFIG.CFC_ISSUER });
          let cfc = '0';
          (al.result.lines||[]).forEach(line=>{
            if(line.currency===CONFIG.CFC_CURRENCY){ cfc = line.balance; }
          });
          setCfc(cfc);
          const hasLine = (al.result.lines||[]).some(l => l.currency===CONFIG.CFC_CURRENCY);
          if(wtrust) wtrust.style.display = hasLine ? 'none' : 'inline-block';
        }catch(e){
          setCfc('‚Äî');
          if(wtrust) wtrust.style.display = 'inline-block';
        }
      }else{
        setCfc('‚Äî');
      }
      client.disconnect();
    }catch(e){ console.warn(e); }
  }

  async function doConnect(){
    try{
      if(!window.xumm){ alert('Xaman SDK not ready'); return; }
      setStatus('Connecting‚Ä¶');
      const r = await xumm.authorize();
      const ping = await xumm.ping();
      if(ping && ping?.account){ account = ping.account; }
      if(!account && xumm?.user?.account) account = xumm.user.account;
      if(account){
        connected = true;
        localStorage.setItem('xrpl_account', account);
        showBar(); setStatus('Connected'); setAccount(account);
        try{var _b=document.getElementById('connectBtn'); if(_b){ _b.textContent='Connected'; _b.disabled=false; }}catch(e){} connectXRPLAndLoadBalances(account);
      }else{
        setStatus('Not connected');
        alert('Could not get account from Xaman');
      }
    }catch(e){
      setStatus('Not connected');
      console.error(e);
      alert('Connect failed');
    }
  }

  const connectBtn = gid('connectBtn');
  if(connectBtn && !connectBtn.__wired){
    connectBtn.__wired = true;
    connectBtn.addEventListener('click', doConnect);
  }
  if(account){
    showBar(); setStatus('Connected'); setAccount(account);
    try{var _b=document.getElementById('connectBtn'); if(_b){ _b.textContent='Connected'; _b.disabled=false; }}catch(e){} connectXRPLAndLoadBalances(account);
  }

  const claimBtn = gid('claimBtn');
  const claimStatus = gid('claimStatus');
  const claimSpin = gid('claimSpin');
  const capQ = gid('capQ'), capA = gid('capA'), capRefresh = gid('capRefresh');
  let a=0,b=0;
  function regen(){
    if(!capQ) return;
    a = Math.floor(Math.random()*10); b = Math.floor(Math.random()*10);
    capQ.textContent = 'Solve: ' + a + ' + ' + b + ' = ?';
    if(capA) capA.value='';
  }
  if(capRefresh) capRefresh.addEventListener('click', regen);
  if(document.readyState!=='loading') regen(); else document.addEventListener('DOMContentLoaded', regen);

  async function postJson(url, data){
    const r = await fetch(url, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(data||{}) });
    return r.json();
  }

  if(claimBtn && !claimBtn.__wired){
    claimBtn.__wired = true;
    claimBtn.addEventListener('click', async function(){
      if(capQ && capA){
        const ans = parseInt(capA.value||'NaN',10);
        if(isNaN(ans) || ans !== (a+b)){
          if(claimStatus){ claimStatus.className='status err'; claimStatus.textContent='Wrong math answer'; }
          return;
        }
      }
      if(!account){
        alert('Connect Xaman first so we know your account.');
        return;
      }
      if(claimStatus){ claimStatus.className='status warn'; claimStatus.textContent='Sending‚Ä¶'; }
      if(claimSpin){ claimSpin.style.display='inline-block'; }
      try{
        const j = await postJson(CONFIG.FAUCET_ENDPOINT, { captcha_ok:true, account });
        if(j && j.ok){
          if(claimStatus){ claimStatus.className='status ok'; claimStatus.textContent='‚úÖ 25 CFC sent (pending ledger)‚Ä¶'; }
          setTimeout(()=>connectXRPLAndLoadBalances(account), 8000);
        }else{
          if (claimStatus){ 
  claimStatus.className='status err'; 
  claimStatus.textContent=''; 
}
        }
      }catch(e){
        if(claimStatus){ claimStatus.className='status err'; claimStatus.textContent='Network error'; }
      }finally{
        if(claimSpin){ claimSpin.style.display='none'; }
      }
    });
  }

  const joinEmail = gid('joinEmail') || gid('emailInput');
  const joinBtn = gid('joinBtn') || gid('emailSubmit');
  const joinStatus = gid('joinStatus') || gid('emailMsg');
  if(joinBtn && !joinBtn.__wired){
    joinBtn.__wired = true;
    joinBtn.addEventListener('click', async function(){
      const email = (joinEmail && joinEmail.value || '').trim();
      if(!email || !/\\S+@\\S+\\.\\S+/.test(email)){
        if(joinStatus){ joinStatus.className='status err'; joinStatus.textContent='Enter a valid email'; }
        return;
      }
      if(joinStatus){ joinStatus.className='status warn'; joinStatus.textContent='Submitting‚Ä¶'; }
      try{
        const j = await postJson(CONFIG.JOIN_ENDPOINT, { email });
        if(j && j.ok){
          if(joinStatus){ joinStatus.className='status ok'; joinStatus.textContent='üéâ You‚Äôre in!'; }
          if(joinEmail) joinEmail.value='';
        }else{
          if(joinStatus){ joinStatus.className='status err'; joinStatus.textContent=(j&&j.error)||'Join failed'; }
        }
      }catch(e){
        if(joinStatus){ joinStatus.className='status err'; joinStatus.textContent='Network error'; }
      }
    });
  }

  
  if(wtrust && !wtrust.__wired){
    wtrust.__wired = true;
    wtrust.addEventListener('click', async function(){
      try{
        if(!window.xumm){ alert('Xaman SDK not ready'); return; }
        if(!CONFIG.CFC_ISSUER){ alert('Missing CONFIG.CFC_ISSUER'); return; }
        const payload = {
          "TransactionType": "TrustSet",
          "LimitAmount": {
            "currency": CONFIG.CFC_CURRENCY,
            "issuer": CONFIG.CFC_ISSUER,
            "value": "1000000000"
          }
        };
        const res = await xumm.payload.create(payload);
        if(res?.next?.always){
          window.open(res.next.always, "_blank");
        } else {
          alert('Could not create trustline payload');
        }
      }catch(e){
        console.error(e);
        alert('Trustline failed');
      }
    });
  }
})();
</script>
<script>
(function(){
  // augment config safely
  window.CONFIG = Object.assign(window.CONFIG||{}, {
    JOIN_ENDPOINT: 'https://cfc-faucet.onrender.com/api/join',
    PAY_CFC_URL: 'https://cfc-faucet.onrender.com/api/pay-cfc',
    PAY_XRP_URL: 'https://cfc-faucet.onrender.com/api/pay-xrp',
    XRPL_WS: 'wss://xrplcluster.com',
    XUMM_APP_UUID: 'eebd4c17-c3ef-435b-b891-89afb99e259e'
  });
  var CFG = window.CONFIG;

  // Xumm loader (avoid duplicates)
  if(!window.xumm && typeof Xumm!=='undefined'){
    try{ window.xumm = new Xumm(CFG.XUMM_APP_UUID); console.log('Constructed Xumm Object'); }catch(e){}
  }

  function byId(id){ return document.getElementById(id); }

  // Connect handler
  var connectedAccount = null;
  function connectXaman(){
    try{
      if(!window.Xumm){ console.warn('Xumm SDK not loaded'); return; }
      var x = new Xumm(CFG.XUMM_APP_UUID);
      x.signIn().then(function(s){
        if (s && s.me && s.me.account){
          connectedAccount = s.me.account;
          var cs = byId('connStatus'); if(cs) cs.textContent='Connected';
          var ac = byId('acct'); if(ac) ac.textContent=connectedAccount;
          refreshBalances();
        }
      });
    }catch(e){ console.error(e); }
  }
  var btn = document.getElementById('connectBtn');
  if(btn){ btn.addEventListener('click', connectXaman); }

  // XRPL read balances
  var xrplClient = null;
  async function getClient(){
    if (xrplClient && xrplClient.isConnected()) return xrplClient;
    xrplClient = new xrpl.Client(CFG.XRPL_WS);
    await xrplClient.connect();
    return xrplClient;
  }
  async function refreshBalances(){
    if(!connectedAccount) return;
    try {
      var c = await getClient();
      try{
        var ai = await c.request({ command:'account_info', account:connectedAccount, ledger_index:'validated' });
        var xrp = (ai.result && ai.result.account_data && ai.result.account_data.Balance) ? (ai.result.account_data.Balance/1e6).toFixed(6) : '‚Äî';
        var el = byId('xrpBal'); if(el) el.textContent = xrp;
      }catch(e){}
      try{
        var al = await c.request({ command:'account_lines', account:connectedAccount, ledger_index:'validated' });
        var line = ((al.result && al.result.lines) || []).find(function(l){ return l.currency==='CFC'; });
        var cfc = line ? line.balance : '‚Äî';
        var el2 = byId('cfcBal'); if(el2) el2.textContent = cfc;
      }catch(e){}
    }catch(e){ console.warn(e); }
  }

  // Hook faucet Claim button to pass account
  var claimBtn = document.getElementById('claimBtn');
  if(claimBtn){
    claimBtn.addEventListener('click', function(){
      // If page has existing handler, we don't override; we look for a known status element to update after
      // Instead, we intercept fetch by exposing CONFIG.FAUCET_ENDPOINT and expecting app code to read CONFIG
      // No-op here.
    });
  }

  // Patch Claim to include account if site uses a global sendClaim function
  if (typeof window.sendClaim==='function'){
    var orig = window.sendClaim;
    window.sendClaim = function(){
      try{
        if (connectedAccount) window.__connectedAccount = connectedAccount;
      }catch(e){}
      return orig.apply(this, arguments);
    }
  }
})();
</script>
<script>
(function(){
  // Globals
  const connectBtn = document.getElementById('connectBtn');
  const cfcBalEl = document.getElementById('cfcBal');
  const xrpBalEl = document.getElementById('xrpBal');
  const addrBadge = document.getElementById('addrBadge');

  let connectedAccount = null;

  async function fetchBalances(address){
    try{
      if(!window.xrpl) return;
      const client = new xrpl.Client("wss://s1.ripple.com");
      await client.connect();
      // XRP balance
      const acct = await client.request({ command: "account_info", account: address, ledger_index: "validated" });
      const xrpDrops = acct.result.account_data.Balance || "0";
      const xrp = (parseInt(xrpDrops,10)/1000000).toFixed(6);
      if(xrpBalEl) xrpBalEl.textContent = xrp;

      // CFC balance (trustline) currency = CFC, any issuer (or specific if provided via CONFIG)
      const lines = await client.request({ command: "account_lines", account: address, ledger_index: "validated" });
      const cfcLine = (lines.result.lines || []).find(l => (l.currency === (window.CONFIG && window.CONFIG.currencyCode ? window.CONFIG.currencyCode : "CFC")));
      if(cfcBalEl) cfcBalEl.textContent = cfcLine ? cfcLine.balance : "0";
      await client.disconnect();
    }catch(e){
      console.error("balance fetch error", e);
    }
  }

  async function connectXumm(){
    try{
      if(window.xumm && window.xumm.authorize){
        const res = await window.xumm.authorize();
        if(res && res.me && res.me.account){
          connectedAccount = res.me.account;
          if(connectBtn){ connectBtn.textContent = "Connected"; connectBtn.disabled = false; }
          if(addrBadge){ addrBadge.textContent = connectedAccount; }
          fetchBalances(connectedAccount);
        }
      }
    }catch(e){
      console.error(e);
      toast && toast("Xaman connect failed");
    }
  }

  if(connectBtn){
    connectBtn.addEventListener('click', function(){
      // If already connected, do nothing
      if(connectedAccount){ return; }
      connectXumm();
    });
  }

  // Provide a global for other handlers (Claim) to know connection
  window.__cfcConnectedAccount = () => connectedAccount;


    });
  }

  // Try to auto-connect silently if session exists
  if(window.xumm){
    try{
      window.xumm.on("ready", ()=>{
        // no-op; explicit connect on click
      });
    }catch(e){}
  }
})();
</script>
<!-- CFC-AUTO-SCRIPT -->
<script>
(function(){
  const connectBtn = document.getElementById('connectBtn');
  const addrBadge  = document.getElementById('addrBadge');
  const xrpBalEl   = document.getElementById('xrpBal');
  const cfcBalEl   = document.getElementById('cfcBal');
  const claimBtn   = document.getElementById('claimBtn');
  const CONFIG     = window.CONFIG || {};
  let connectedAccount = null;

  function isValidR(r){ return typeof r === 'string' && /^r[1-9A-HJ-NP-Za-km-z]{25,}$/i.test(r); }
  function setConnected(addr){
    if(!isValidR(addr)) return;
    connectedAccount = addr;
    try { sessionStorage.setItem("cfc_addr", addr); } catch(e){}
    if(connectBtn){ connectBtn.textContent = "Connected"; connectBtn.disabled = false; }
    if(addrBadge){ addrBadge.textContent = addr; }
    fetchBalances(addr);
  }

  async function fetchBalances(address){
    try{
      if(!window.xrpl) return;
      const client = new xrpl.Client("wss://s1.ripple.com");
      await client.connect();
      const info = await client.request({ command:"account_info", account: address, ledger_index:"validated" });
      const xrp = (parseInt(info.result.account_data.Balance||"0",10)/1e6).toFixed(6);
      if(xrpBalEl) xrpBalEl.textContent = xrp;
      const code = (CONFIG.currencyCode || "CFC");
      const issuer = (CONFIG.issuer || "rsxUkmjnAn8PRDz8RYrPusb9mTDYn5NqG8");
      const lines = await client.request({ command:"account_lines", account: address, ledger_index:"validated", peer: issuer });
      const line = (lines.result.lines||[]).find(l => l.currency === code);
      if(cfcBalEl) cfcBalEl.textContent = line ? line.balance : "0";
      await client.disconnect();
    }catch(e){ console.error("balance fetch error", e); }
  }

  async function connectXumm(){
    try{
      if(window.xumm && window.xumm.authorize){
        const res = await window.xumm.authorize();
        const addr = res && res.me && res.me.account ? res.me.account : (res && res.account ? res.account : null);
        if(addr) setConnected(addr);
      }
    }catch(e){ console.error("xumm authorize error", e); }
  }

  if(connectBtn){
    connectBtn.addEventListener('click', function(){ if(!connectedAccount) connectXumm(); });
  }

  try{ const prev = sessionStorage.getItem("cfc_addr"); if(isValidR(prev)) setConnected(prev); }catch(e){}

  if(window.xumm && window.xumm.on){
    try{
      window.xumm.on("ready", () => {
        try{ if(window.xumm.user && window.xumm.user.account) setConnected(window.xumm.user.account); }catch(e){}
      });
      window.xumm.on("success", (e) => {
        const acc = (e && e.me && e.me.account) ? e.me.account : (e && e.account ? e.account : null);
        if(acc) setConnected(acc);
      });
      window.xumm.on("retrieved", (e) => {
        const acc = (e && e.me && e.me.account) ? e.me.account : (e && e.account ? e.account : null);
        if(acc) setConnected(acc);
      });
    }catch(e){}
  }

    });
  }
})();
</script>
</div></div>
<script>
(function() {
  // Configuration
  const API_BASE = (typeof window.CFC_API_BASE !== 'undefined' && window.CFC_API_BASE) || "https://cfc-faucet.onrender.com";
  const XUMM_API_KEY = "eebd4c17-c3ef-435b-b891-89afb99e259e";

  // DOM refs
  const connectBtn = document.getElementById('connectXaman') || document.querySelector('[data-connect-xaman]');
  const addrSpan = document.getElementById('connectedAddress');
  const xrpSpan = document.getElementById('xrpBalance');
  const cfcSpan = document.getElementById('cfcBalance');
  const claimBtn = document.getElementById('claimButton') || document.querySelector('[data-claim]');
  const captchaInput = document.getElementById('captchaAnswer') || document.querySelector('[data-captcha-answer]');
  const captchaA = document.getElementById('captchaA') || document.querySelector('[data-captcha-a]');
  const captchaB = document.getElementById('captchaB') || document.querySelector('[data-captcha-b]');
  const statusArea = document.getElementById('statusArea') || document.querySelector('[data-status]');

  // Styling guarantee: do not change colors; only set states
  function setStatus(msg) {
    if (statusArea) { statusArea.textContent = msg; }
    console.log(msg);
  }

  // XUMM SDK
  let xumm;
  let connectedAccount = null;

  function initXumm() {
    try {
      // The SDK is served from /sdk/xumm.min.js on the backend domain; ensure it's loaded
      if (typeof Xumm === 'undefined') {
        console.warn('Xumm SDK not found on window. Make sure /sdk/xumm.min.js is included.');
        return;
      }
      xumm = new Xumm(XUMM_API_KEY);
      // Restore session if any
      xumm.on('ready', () => {
        setStatus('Xaman SDK ready');
      });
      xumm.on('success', () => {
        // Authorization success
        if (xumm?.user?.account) {
          applyConnected(xumm.user.account);
        }
      });
      xumm.on('retrieved', () => {
        if (xumm?.user?.account) {
          applyConnected(xumm.user.account);
        }
      });
    } catch (e) {
      console.error('Xumm init error:', e);
    }
  }

  function truncate(addr) {
    if (!addr) return '';
    return addr.slice(0, 6) + '...' + addr.slice(-6);
  }

  async function refreshBalances(address) {
    try {
      if (!address) return;
      const res = await fetch(API_BASE + '/api/balances?account=' + encodeURIComponent(address));
      if (!res.ok) throw new Error('Balances fetch failed');
      const data = await res.json();
      if (typeof data.xrp !== 'undefined' && xrpSpan) xrpSpan.textContent = data.xrp;
      if (typeof data.cfc !== 'undefined' && cfcSpan) cfcSpan.textContent = data.cfc;
    } catch (e) {
      console.warn('Balance update failed', e);
    }
  }

  function applyConnected(address) {
    connectedAccount = address;
    if (addrSpan) addrSpan.textContent = address || 'Not connected';
    // Also show a short form if there's an element for it
    const shortAddrEl = document.getElementById('connectedAddressShort');
    if (shortAddrEl) shortAddrEl.textContent = truncate(address);
    // Enable claim now that we have an account
    if (claimBtn) claimBtn.removeAttribute('disabled');
    refreshBalances(address);
  }

  async function handleConnect() {
    try {
      // If already connected, just ensure UI is up to date
      if (connectedAccount && xumm?.user?.account) {
        applyConnected(connectedAccount);
        return;
      }
      setStatus('Connecting wallet...');
      await xumm.authorize();
      // `success` event will update UI
    } catch (e) {
      setStatus('Connection canceled or failed.');
    }
  }

  function generateCaptchaIfNeeded() {
    if (!captchaA || !captchaB || !captchaInput) return;
    // Assume the numbers are already rendered by backend/page; if not, set defaults
    const a = parseInt(captchaA.textContent || captchaA.value || '0', 10);
    const b = parseInt(captchaB.textContent || captchaB.value || '0', 10);
    if (Number.isNaN(a) || Number.isNaN(b)) {
      // Generate simple fallback numbers
      const aa = Math.floor(1 + Math.random() * 9);
      const bb = Math.floor(1 + Math.random() * 9);
      captchaA.textContent = String(aa);
      captchaB.textContent = String(bb);
    }
  }

  async function handleClaim() {
    try {
      if (!connectedAccount || connectedAccount === 'undefined' || connectedAccount === null) {
        setStatus('Please connect your wallet first.');
        if (connectBtn) connectBtn.focus();
        return;
      }
      // Validate captcha
      if (!captchaA || !captchaB || !captchaInput) {
        setStatus('Captcha not found.');
        return;
      }
      const a = parseInt(captchaA.textContent || captchaA.value || '0', 10);
      const b = parseInt(captchaB.textContent || captchaB.value || '0', 10);
      const ans = parseInt(captchaInput.value || '0', 10);
      if (ans !== (a + b)) {
        setStatus('Captcha incorrect. Please try again.');
        captchaInput.focus();
        return;
      }
      setStatus('Requesting faucet...');
      const res = await fetch(API_BASE + '/api/faucet', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ account: connectedAccount, captcha_ok: true })
      });
      if (!res.ok) {
        const t = await res.text();
        throw new Error(t || 'Faucet failed');
      }
      const data = await res.json().catch(()=>({}));
      setStatus('Faucet sent: 25 CFC. Check your wallet.');
      // Refresh balances after a short delay
      setTimeout(() => refreshBalances(connectedAccount), 1500);
    } catch (e) {
      console.error(e);
      setStatus('Faucet error: ' + (e.message || 'Unknown error'));
    }
  }

  // Bind events
  document.addEventListener('DOMContentLoaded', () => {
    initXumm();
    generateCaptchaIfNeeded();
    if (connectBtn) connectBtn.addEventListener('click', handleConnect);
    if (claimBtn) claimBtn.addEventListener('click', handleClaim);
    // Disable claim until connected
    if (claimBtn) claimBtn.setAttribute('disabled', 'disabled');
  });
})();
</script>
<script>
(() => {
  let connectedAccount = null;

  async function restore() {
    try {
      const saved = localStorage.getItem('xummAccount');
      if (saved) {
        connectedAccount = saved;
        const el = document.getElementById('connectedAddress');
        if (el) el.textContent = saved;
        if (typeof fetchBalances === 'function') {
          await fetchBalances(saved);
        }
      }
    } catch(e) { console.error(e); }
  }

  async function connectNow() {
    try {
      if (typeof ensureConnected === 'function') {
        const acc = await ensureConnected();
        if (acc) {
          connectedAccount = acc;
          localStorage.setItem('xummAccount', acc);
          const el = document.getElementById('connectedAddress');
          if (el) el.textContent = acc;
          if (typeof fetchBalances === 'function') {
            await fetchBalances(acc);
          }
        }
      } else if (window.xumm && typeof xumm.authorize === 'function') {
        const { me } = await xumm.authorize();
        connectedAccount = me.account;
        localStorage.setItem('xummAccount', connectedAccount);
        const el = document.getElementById('connectedAddress');
        if (el) el.textContent = connectedAccount;
        if (typeof fetchBalances === 'function') {
          await fetchBalances(connectedAccount);
        }
      }
    } catch (e) {
      console.error('Connect error', e);
      const s = document.getElementById('claimStatus');
      if (s) s.textContent = 'Connection failed. Please try again.';
    }
  }

  async function claim() {
    const s = document.getElementById('claimStatus');
    if (!connectedAccount || connectedAccount === 'undefined' || connectedAccount === null) {
      if (s) s.textContent = 'Connect Wallet First';
      return;
    }
    try {
      const resp = await fetch('https://cfc-faucet.onrender.com/api/faucet', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ account: connectedAccount, captcha_ok: true })
      });
      const data = await resp.json();
      if (data.ok) {
        if (s) s.textContent = 'Success! Faucet sent.';
        if (typeof fetchBalances === 'function') await fetchBalances(connectedAccount);
      } else {
        if (s) s.textContent = data.error || 'Faucet failed.';
      }
    } catch (e) {
      if (s) s.textContent = 'Network error.';
    }
  }

  window.addEventListener('load', restore);
  const btn = document.getElementById('connectBtn');
  if (btn) btn.addEventListener('click', connectNow);
  const cbtn = document.getElementById('claimBtn');
  if (cbtn) cbtn.addEventListener('click', (e)=>{ e.preventDefault(); claim(); });
})();
</script>

<!-- Injected: targeted fixes overlay -->
<script>
(function(){
  function gid(id){ return document.getElementById(id); }
  function $all(sel){ return Array.from(document.querySelectorAll(sel)); }
  function acct(){
    if (typeof window.connectedAccount === 'string' && window.connectedAccount) return window.connectedAccount;
    try{ const s = localStorage.getItem('xummAccount'); if (s) return s; }catch(e){}
    return "";
  }
  function isR(a){ return typeof a==='string' && /^r[1-9A-HJ-NP-Za-km-z]{25,34}$/.test(a); }

  function updateWallet(){
    var a = acct();
    var targets = [gid('wallet-address'), gid('connectedAddress'), gid('addrBadge'), gid('walletbar')].filter(Boolean);
    targets.forEach(function(el){
      try{ el.innerHTML = el.innerHTML.replace('[object Promise]','').replace(/XRP:\s*‚Äî?/gi,'').replace(/CFC:\s*‚Äî?/gi,''); }catch(e){}
      el.textContent = (isR(a) ? 'Connected Account: ' + a : 'Wallet Status: CONNECT');
    });
    var btn = gid('connect-wallet') || gid('connectXumm') || gid('xummConnect') || gid('connectBtn');
    if (btn) btn.textContent = isR(a) ? 'Disconnect XAMAN Wallet' : 'Connect XAMAN Wallet';
  }

  function connectToggle(){
    var btn = gid('connect-wallet') || gid('connectXumm') || gid('xummConnect') || gid('connectBtn');
    if (!btn) return;
    var clone = btn.cloneNode(true);
    btn.parentNode.replaceChild(clone, btn);
    clone.addEventListener('click', async function(e){
      e.preventDefault();
      var a = acct();
      if (isR(a)){
        try{ localStorage.removeItem('xummAccount'); }catch(e){}
        if (typeof window.connectedAccount !== 'undefined') window.connectedAccount = null;
        updateWallet();
        return;
      }
      try{
        if (window.xumm && typeof window.xumm.authorize === 'function'){
          // Enhanced full disconnect before returning
          try{
            if (window.xumm && typeof window.xumm.logout === 'function') {
              await window.xumm.logout();
            }
          }catch(_){}
          try{
            // Clear any XUMM-related storage to force QR on reconnect
            (function(){
              try{
                for (var i=0; i<localStorage.length; i++){
                  var k = localStorage.key(i);
                  if (/^xumm/i.test(k)) { localStorage.removeItem(k); i--; }
                }
              }catch(_){}
              try{
                for (var j=0; j<sessionStorage.length; j++){
                  var s = sessionStorage.key(j);
                  if (/^xumm/i.test(s)) { sessionStorage.removeItem(s); j--; }
                }
              }catch(_){}
            })();
          }catch(_){}

          const { me } = await window.xumm.authorize();
          if (me && me.account){
            window.connectedAccount = me.account;
            try{ localStorage.setItem('xummAccount', me.account); }catch(e){}
            updateWallet();
          }
        } else {
          alert('XUMM SDK not loaded.');
        }
      }catch(_){ alert('Wallet connection failed.'); }
    });
  }

  // Suppress redundant "connect wallet" alerts if already connected
  (function(){
    var nat = window.alert;
    window.alert = function(msg){
      if (isR(acct()) && typeof msg === 'string' && /connect wallet/i.test(msg)) return;
      return nat.apply(window, arguments);
    };
  })();

  // Auto-clear success message after 5s
  (function(){
    var nodes = [gid('faucet-result'), gid('claimStatus')].filter(Boolean);
    nodes.forEach(function(node){
      var obs = new MutationObserver(function(){
        var txt = (node.textContent || '').toLowerCase();
        if (txt.includes('success') && txt.includes('faucet')){
          setTimeout(function(){ node.textContent=''; }, 5000);
        }
      });
      obs.observe(node, { childList:true, subtree:true, characterData:true });
    });
  })();

  function init(){
    updateWallet();
    connectToggle();
    cleanTexts();
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
  setTimeout(updateWallet, 1000);
  setInterval(updateWallet, 4000);
})();
</script>
</body>
<script>
(function(){
  // local helpers (no globals)
  var $ = function(sel, root){ return (root||document).querySelector(sel); };

  // Discover elements actually present in your page
  var claimBtn = document.getElementById('claimBtn') || document.querySelector('#faucet button.btn');
  var claimStatus = document.getElementById('claimStatus') || document.querySelector('#faucet .status');
  var claimSpin = document.getElementById('claimSpin');
  var capQ = document.getElementById('capQ');
  var capA = document.getElementById('capA');
  var capRefresh = document.getElementById('capRefresh');

  var joinForm = document.getElementById('joinForm');
  var joinEmail = document.getElementById('joinEmail') || document.getElementById('emailInput');
  var joinBtn = document.getElementById('joinBtn') || document.getElementById('emailSubmit');
  var joinStatus = document.getElementById('joinStatus') || document.getElementById('emailMsg');

  // Endpoints (use existing if already in your page's CONFIG)
  var FAUCET_ENDPOINT = (window.CONFIG && window.CONFIG.FAUCET_ENDPOINT) || 'https://cfc-faucet.onrender.com/api/faucet';

  // Captcha (only if those elements exist)
  var a=0,b=0;
  function regen(){
    if (!capQ) return;
    a = Math.floor(Math.random()*10);
    b = Math.floor(Math.random()*10);
    capQ.textContent = 'Solve: ' + a + ' + ' + b + ' = ?';
    if (capA) capA.value = '';
  }
  if (capRefresh) capRefresh.addEventListener('click', regen);
  if (capQ) { if (document.readyState !== 'loading') regen(); else document.addEventListener('DOMContentLoaded', regen); }

  async function postJson(url, data){
    const r = await fetch(url, {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify(data||{})
    });
    return r.json();
  }

    });
  }

  // Wire JOIN
  var joinHandlerTarget = joinBtn || (joinForm && joinForm);
  if (joinHandlerTarget && !joinHandlerTarget.__wired){
    joinHandlerTarget.__wired = true;
    var handler = async function(ev){
      if (ev && ev.preventDefault) ev.preventDefault();
      var email = (joinEmail && joinEmail.value || '').trim();
      if (!email || !/\S+@\S+\.\S+/.test(email)){
        if (joinStatus){ joinStatus.className='status err'; joinStatus.textContent='Enter a valid email'; }
        return false;
      }
      if (joinStatus){ joinStatus.className='status warn'; joinStatus.textContent='Submitting‚Ä¶'; }
      try{
        const j = await postJson(JOIN_ENDPOINT, { email });
        if (j && j.ok){
          if (joinStatus){ joinStatus.className='status ok'; joinStatus.textContent='üéâ You‚Äôre in!'; }
          if (joinEmail) joinEmail.value='';
        } else {
          if (joinStatus){ joinStatus.className='status err'; joinStatus.textContent=(j&&j.error)||'Join failed'; }
        }
      }catch(e){
        if (joinStatus){ joinStatus.className='status err'; joinStatus.textContent='Network error'; }
      }
      return false;
    };
    if (joinBtn) joinBtn.addEventListener('click', handler);
    if (joinForm) joinForm.addEventListener('submit', handler);
  }
})();
</script>
</html>
<!-- ‚úÖ Helper: Hide unwanted text -->
<script>
function cleanTexts(){
  document.querySelectorAll('body *').forEach(function(n){
    var t = (n.innerText || n.textContent || '').trim();
    if (/invalid account/i.test(t) || /^server:\s*waiting for url\.?$/i.test(t)){
      n.style.display = 'none';
    }
  });
}
</script>

<!-- bootstrap: join + claim + divider (non-destructive) -->
<script>
(function(){

<!-- bootstrap: join + claim + divider (non-destructive) -->
<script>
(function(){
  
  function create(tag, attrs){
    var el = document.createElement(tag);
    if(attrs){ for (var k in attrs){ if(k==='text') el.textContent = attrs[k]; else el.setAttribute(k, attrs[k]); } }
    return el;
  }

  // Add .divider CSS if missing
  function ensureDividerCSS(){
    if ([].some.call(document.styleSheets, s => {
      try { return s.ownerNode && s.ownerNode.textContent && s.ownerNode.textContent.includes('.divider{'); } catch(e){ return false; }
    })) return;
    var style = create('style');
    style.textContent = '.divider{height:1px;background:var(--accent);opacity:0.6;margin:10px 0 14px 0;border-radius:999px}';
    document.head.appendChild(style);
  }

  // Insert divider under CAPTCHA and above Marketplace/My Purchases/Redeem
  function ensureFaucetDivider(){
    var faucet = $('#faucet');
    if (!faucet) return;
    if (faucet.querySelector('.divider')) return;
    var cap = faucet.querySelector('.captcha');
    if (cap){
      var div = create('div'); div.className = 'divider';
      cap.insertAdjacentElement('afterend', div);
      return;
    }
    // fallback: before row containing the 3 buttons
    var rows = faucet.querySelectorAll('.row');
    for (var i=0;i<rows.length;i++){
      var t = rows[i].textContent || '';
      if (/Marketplace|My Purchases|Redeem/i.test(t)){
        var div2 = create('div'); div2.className = 'divider';
        rows[i].insertAdjacentElement('beforebegin', div2);
        break;
      }
    }
  }

  // Ensure claim spinner/status elements after claimBtn
  function ensureClaimUI(){
    var btn = $('#claimBtn');
    if (!btn) return;
    var next = btn.nextElementSibling;
    var hasSpin = !!$('#claimSpin', btn.parentElement || document);
    var hasStatus = !!$('#claimStatus', btn.parentElement || document) || !!document.getElementById('claimStatus');
    if (!hasSpin){
      var spin = create('div', { id:'claimSpin', class:'spinner' });
      spin.style.display = 'none';
      btn.insertAdjacentElement('afterend', spin);
    }
    if (!hasStatus){
      var status = create('div', { id:'claimStatus', class:'status' });
      (btn.parentElement||faucet||document.body).appendChild(status);
    }
  }

  <script>
/* SAFE claim handler: no backend error text is surfaced */
(function(){
  var btn = document.getElementById('claimBtn')
      || document.querySelector('#faucet button.btn');
  if (!btn) return;
  if (btn.__wired) return;
  btn.__wired = true;

  btn.addEventListener('click', async function (ev) {
    ev.preventDefault();
    var status = document.getElementById('claimStatus')
        || document.querySelector('#faucet .status');
    var spin = document.getElementById('claimSpin');

    if (status){ status.className='status warn'; status.textContent='Sending‚Ä¶'; }
    if (spin){ spin.style.display='inline-block'; }

    try {
      const url = (window.CONFIG && (CONFIG.FAUCET_ENDPOINT || CONFIG.faucetEndpoint))
                  || 'https://cfc-faucet.onrender.com/api/faucet';
      const r = await fetch(url, {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ captcha_ok: true })
      });
      const j = await r.json();

      if (status){
        if (j && j.ok){
          var amt = (window.CONFIG && (CONFIG.faucetAmount || CONFIG.FAUCET_DAILY_AMOUNT)) || 10;
          var code = (window.CONFIG && (CONFIG.currencyCode || CONFIG.CFC_CODE)) || 'CFC';
          status.className='status ok';
          status.textContent='‚úÖ ' + amt + ' ' + code + ' sent!';
        } else {
          status.className='status err';
          status.textContent='Request failed';
          setTimeout(()=>{ statusEl.textContent=''; statusEl.className='status'; }, 5000);
        }
      }
    
</script>
<script id="cfc-connect-and-bindings">
(function(){
  if(window._cfcPatched) return; window._cfcPatched = true;
  const connectBtn = document.getElementById('connectBtn');
  const claimBtn = document.getElementById('claimBtn');
  const ans = document.getElementById('capAns');
  const addrBadge = document.getElementById('addrBadge') || document.getElementById('address') || document.getElementById('walletAddress');

  if(connectBtn){
    connectBtn.onclick = null;
    connectBtn.addEventListener('click', async function(){
      try{
        if(window.xumm && window.xumm.authorize){
          const res = await window.xumm.authorize();
          const acct = (res && (res.account || (res.me && res.me.account))) ? (res.account || res.me.account) : null;
          if(acct){
            window.connectedAccount = acct;
            if(connectBtn){ connectBtn.textContent = 'Connected'; connectBtn.disabled = false; }
            if(addrBadge){ addrBadge.textContent = acct; }
            if(typeof fetchBalances==='function') fetchBalances(acct);
          }
        }
      }catch(e){ console.error('Xaman connect error', e); }
    });
  }
  
  if(ans){ ans.addEventListener('input', function(){ if(typeof checkCaptcha==='function') checkCaptcha(); }); }
  if(typeof newCaptcha==='function') newCaptcha();
})();
<script>
document.addEventListener("DOMContentLoaded", () => {
  const savedAccount = localStorage.getItem("connectedAccount");
  if (savedAccount) {
    connectedAccount = savedAccount;
    const connectBtn = document.getElementById("connect-btn");
    const walletAddr = document.getElementById("wallet-address");
    if (connectBtn) connectBtn.textContent = "Connected";
    if (walletAddr) walletAddr.textContent = connectedAccount ? `Connected Wallet: ${connectedAccount}` : '';
    if (typeof updateBalances === 'function') updateBalances(savedAccount);
  }
});
</script>

<!-- This block was showing as text; it MUST live inside <script> -->
<script>
try {
  // (nothing here on purpose: you only had closing parts visible)
} catch (e) {
  if (statusEl){
    statusEl.className='status err';
    statusEl.textContent='Network error';
    setTimeout(()=>{ statusEl.textContent=''; statusEl.className='status'; }, 5000);
  }
} finally {
  if (spin){ spin.style.display='none'; }
}
</script>

<script>
(function(){
  function create(tag, attrs){
    var el = document.createElement(tag);
    if(attrs){ for (var k in attrs){ if(k==='text') el.textContent = attrs[k]; else el.setAttribute(k, attrs[k]); } }
    return el;
  }

  // Ensure Join form exists inside #join
  function ensureJoinForm(){
    var join = document.getElementById('join') || document.querySelector('section#join');
    if (!join) return;
    var form = document.getElementById('joinForm');
    if (!form){
      var container = create('div'); container.style.maxWidth = '420px';
      container.style.marginTop = '10px';
      var f = create('form', { id:'joinForm' }); f.className = 'row'; f.setAttribute('onsubmit','return false;');
      var inp = create('input', { id:'joinEmail', type:'email', placeholder:'you@example.com' });
      var btn = create('button', { id:'joinBtn', type:'submit' }); btn.className = 'btn'; btn.textContent = 'Join';
      f.appendChild(inp); f.appendChild(btn);
      var st = create('div', { id:'joinStatus' }); st.className = 'status';
      container.appendChild(f); container.appendChild(st);
      join.appendChild(container);
    }
  }

  // Wire Join submit (leave endpoint as-is if you‚Äôre still using faucet join; otherwise swap URL)
  function wireJoin(){
    var form = document.getElementById('joinForm');
    if (!form || form.__wired) return;
    form.__wired = true;
    form.addEventListener('submit', async function(ev){
      ev.preventDefault();
      var emailEl = document.getElementById('joinEmail');
      var statusEl = document.getElementById('joinStatus');
      var email = (emailEl && emailEl.value || '').trim();
      if(!email){ if(statusEl){ statusEl.className='status err'; statusEl.textContent='Enter an email'; } return; }
      if(statusEl){ statusEl.className='status warn'; statusEl.textContent='Submitting‚Ä¶'; }
      try{
        const res = await fetch((CONFIG && CONFIG.USE_CORS_PROXY ? (CONFIG.CORS_PROXY + 'https://cfc-faucet.onrender.com/api/join') : 'https://cfc-faucet.onrender.com/api/join'), {
          method:'POST', headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ email })
        });
        const j = await res.json();
        if (statusEl){
          if (j && j.ok){
            statusEl.className='status ok'; statusEl.textContent='üéâ You‚Äôre in!';
            if (emailEl) emailEl.value='';
          } else {
            statusEl.className='status err'; statusEl.textContent=(j && j.error) || 'Join failed';
          }
        }
      }catch(e){
        if(statusEl){ statusEl.className='status err'; statusEl.textContent='Network error'; }
      }
    });
  }

  // Optional helper to hide unwanted text
  function cleanTexts(){
    document.querySelectorAll('body *').forEach(function(n){
      var t = (n.innerText || n.textContent || '').trim();
      if (/invalid account/i.test(t) || /^server:\s*waiting for url\.?$/i.test(t)){
        n.style.display = 'none';
      }
    });
  }

 function boot(){
  try { if (typeof ensureDividerCSS==='function') ensureDividerCSS(); } catch(e){}
  try { if (typeof ensureFaucetDivider==='function') ensureFaucetDivider(); } catch(e){}
  try { if (typeof ensureClaimUI==='function') ensureClaimUI(); } catch(e){}

  // Delay only the claim wiring by 300ms to improve Chrome wallet sync
  setTimeout(() => {
    try { if (typeof wireClaim==='function') wireClaim(); } catch(e){}
  }, 300);
  
  ensureJoinForm();
  wireJoin();
  
  try { cleanTexts(); } catch(e){}
}

  if (document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', boot); }
  else { boot(); }
  try { new MutationObserver(boot).observe(document.documentElement, { childList:true, subtree:true }); } catch(e){}
})();
</script>
<script>
  document.getElementById('emailSubmit').addEventListener('click', async () => {
    const emailInput = document.getElementById('emailInput');
    const emailMsg = document.getElementById('emailMsg');
    const email = emailInput.value.trim();
    
    if (!email) {
      emailMsg.textContent = 'Please enter a valid email.';
      emailMsg.style.color = '#ff6b6b';
      return;
    }
    
    emailMsg.textContent = 'Submitting...';
    emailMsg.style.color = '#9fb0d1';

    try {
      const response = await fetch('https://cfc-faucet.onrender.com/api/join', {  // Updated to Render backend URL
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email })
      });
      const data = await response.json();

      if (data.ok) {
        emailMsg.textContent = 'Thanks for joining the list!';
        emailMsg.style.color = '#1fcf7c';
        emailInput.value = '';switchView('market')

      } else {
        emailMsg.textContent = 'Error: ' + (data.error || 'Please try again');
        emailMsg.style.color = '#ff6b6b';
      }
    } catch (err) {
      console.error(err);
      emailMsg.textContent = 'Submission failed. Try again later.';
      emailMsg.style.color = '#ff6b6b';
    }
  });
</script>
<script>
/* ================================
   CFC LEARN-TO-EARN (PASSIVE TRACK)
   ADD-ONLY / NO UI / NO REGRESSIONS
================================ */

async function trackLearnAction(submissionId, actionType, actionRef) {
  try {
    // Wallet not connected ‚Üí do nothing
    if (!window.connectedAccount) return;

    await fetch(
      "https://cfc-nft-creator-backend.onrender.com/api/learn/track",
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          wallet: window.connectedAccount,
          submission_id: submissionId,
          action_type: actionType,
          action_ref: actionRef
        })
      }
    );
  } catch {
    // Silent failure ‚Äî no UI impact
  }
}
async function claimCfcReward(submissionId) {
  const wallet = window.connectedAccount;
  const returnUrl = window.location.href;

  const r = await fetch(
    "https://cfc-nft-shared-mint-backend.onrender.com/api/claim-nft-reward",
    {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        wallet,
        submission_id: submissionId,
        return_to: returnUrl
      })
    }
  );

  const j = await r.json();
  if (!j.ok) {
    alert(j.error || "Claim failed");
    return;
  }

  // Redirect to Xaman
  window.location.href = j.link;
}
 
</script>

<script>
  // --------------------------------
  // IFRAME AUTO-HEIGHT (KEEP)
  // --------------------------------
 function sendHeight() {
  const height = Math.max(
    document.body.scrollHeight,
    document.documentElement.scrollHeight
  );
  window.parent.postMessage({ cfcHeight: height }, "*");
}

let lastH = 0;
function sendHeightIfChanged() {
  const h = Math.max(
    document.body.scrollHeight,
    document.documentElement.scrollHeight
  );
  if (h !== lastH) {
    lastH = h;
    window.parent.postMessage({ cfcHeight: h }, "*");
  }
}

// fire EARLY (reduces the ‚Äúscroll then disappear‚Äù effect)
window.addEventListener("DOMContentLoaded", () => {
  sendHeightIfChanged();
  requestAnimationFrame(sendHeightIfChanged);
  setTimeout(sendHeightIfChanged, 50);
  setTimeout(sendHeightIfChanged, 250);
});

// keep a light periodic check
setInterval(sendHeightIfChanged, 1200);

window.addEventListener("load", () => {
  sendHeightIfChanged();
  requestAnimationFrame(sendHeightIfChanged);
});

  // --------------------------------
  // LIVE MARKETPLACE
  // --------------------------------
  const MARKET_API = "https://cfc-nft-shared-mint-backend.onrender.com/api/market/all";
  const MARKET_PAY_XRP = "https://cfc-nft-shared-mint-backend.onrender.com/api/market/pay-xrp";
  const MARKET_PAY_RLUSD = "https://cfc-nft-shared-mint-backend.onrender.com/api/market/pay-rlusd";
function openRedeemedContent(submissionId, metadataCid) {
  const wallet = window.connectedAccount || "";
  const url =
    "./reader.html?submission_id=" + encodeURIComponent(submissionId) +
    "&metadata_cid=" + encodeURIComponent(metadataCid) +
    "&wallet=" + encodeURIComponent(wallet);

  window.open(url, "_blank");
}

  async function cfc_fetchXrpUsd(){
    try {
      const r = await fetch("https://api.coingecko.com/api/v3/simple/price?ids=ripple&vs_currencies=usd");
      const j = await r.json();
      window.cfc_xrp_usd = j.ripple.usd;
    } catch(e){}
  }

  function cfc_calcXrp(usd){
    if(!window.cfc_xrp_usd) return "‚Äî";
    return (usd / window.cfc_xrp_usd).toFixed(2);
  }

  // --------------------------------
  // READ MORE / SEE LESS (3 LINES)
  // --------------------------------
  const style = document.createElement("style");
  style.textContent = `
    .cfc-clamp {
      display: -webkit-box;
      -webkit-box-orient: vertical;
      -webkit-line-clamp: 3;
      overflow: hidden;
    }
    .cfc-expanded {
      -webkit-line-clamp: unset;
    }
    .cfc-toggle {
      cursor: pointer;
      color: #6b5cff;
      font-weight: 500;
      display: inline-block;
      margin-top: 4px;
    }
  `;
  document.head.appendChild(style);

  function toggleReadMore(id){
    const el = document.getElementById(id);
    const btn = document.getElementById(id + "-btn");
    const expanded = el.classList.toggle("cfc-expanded");
    btn.textContent = expanded ? "See less" : "Read more";
    sendHeight();
  }

  function cfc_renderNFT(it){
    const img = `https://gateway.pinata.cloud/ipfs/${it.image_cid}`;
    const xrp = cfc_calcXrp(Number(it.price_rlusd || 0));

    return `
      <div class="card live-nft-card" data-rlusd="${it.price_rlusd}">
       <img class="nft-img" src="${img}" alt="${it.name}" loading="lazy" decoding="async">

        <h3 style="margin:12px 0 4px;">${it.name}</h3>

        <div id="desc-${it.id}" class="muted cfc-clamp">
${it.description || ""}
        </div>
        <span id="desc-${it.id}-btn"
          class="cfc-toggle"
          onclick="toggleReadMore('desc-${it.id}')">Read more</span>
          
${it.website ? `
  <div class="muted" style="margin-top:6px;">
    <a href="${it.website}"
       target="_blank"
       rel="noopener noreferrer">
      Creator website ‚Üí
    </a>
  </div>
` : ""}

        <div id="terms-${it.id}"
          class="muted cfc-clamp"
          style="margin-top:12px;white-space:pre-wrap;"><strong>Terms:</strong> ${it.terms || "‚Äî"}</div>

        <span id="terms-${it.id}-btn"
          class="cfc-toggle"
          onclick="toggleReadMore('terms-${it.id}')">Read more</span>

        <div class="muted" style="margin-top:6px;">
          Quantity: ${it.quantity_remaining}
        </div>
<div class="row" style="justify-content:space-between;margin-top:14px;">
  <div>
    <div class="muted">Price</div>

    <div>
      <strong>${it.price_rlusd} RLUSD</strong>
    </div>

    <div class="muted">¬∑</div>

    <div>
      <strong
        class="live-nft-xrp"
        data-rlusd="${it.price_rlusd}">
        ${xrp} XRP
      </strong>
    </div>
  </div>

          <div class="row">
            <button class="btn small" onclick="cfc_pay_rlusd(${it.id})">Pay RLUSD</button>
            <button class="btn small secondary" onclick="cfc_pay_xrp(${it.id})">Pay XRP</button>
          </div>
        </div>
      </div>
    `;
  }
let cfcMarketLoaded = false;

async function cfc_load_market(){
  if (cfcMarketLoaded) return;
  cfcMarketLoaded = true;

  await cfc_fetchXrpUsd();
  const grid = document.getElementById("cfc-market-grid");
  if(!grid) return;

  const r = await fetch(MARKET_API);
  const items = await r.json();

  window.allMarketItems = items;
  renderFilteredNFTs();

  sendHeight();
}

async function cfc_pay_xrp(id){
  const r = await fetch(MARKET_PAY_XRP,{
    method:"POST",
    headers:{ "Content-Type":"application/json" },
    body: JSON.stringify({ id })
  });
  const j = await r.json();
  if(j.link) window.open(j.link,"_blank");
}

async function cfc_pay_rlusd(id){
  const r = await fetch(MARKET_PAY_RLUSD,{
    method:"POST",
    headers:{ "Content-Type":"application/json" },
    body: JSON.stringify({ id })
  });
  const j = await r.json();
  if(j.link) window.open(j.link,"_blank");
}

document.addEventListener("DOMContentLoaded", cfc_load_market);

/* ===== CATEGORY FILTER ===== */

let activeCategory = "all";
document.querySelectorAll("#cfc-category-tabs .btn").forEach(btn => {
  btn.addEventListener("click", () => {
    document.querySelectorAll(".cfc-tab").forEach(b => b.classList.remove("active"));
    btn.classList.add("active");
    activeCategory = btn.dataset.cat;
    
  if (typeof switchView === "function") {
  switchView("market");
}
setTimeout(renderFilteredNFTs, 0);

  });
});
function renderFilteredNFTs() {
  const grid = document.getElementById("cfc-market-grid");
  if (!grid || !window.allMarketItems) return;

  const filtered =
    activeCategory === "all"
      ? window.allMarketItems
      : window.allMarketItems.filter(n =>
          (n.category || n.metadata?.category) === activeCategory
        );

  grid.innerHTML = filtered.map(cfc_renderNFT).join("");
}

/* ===== PRICE REFRESH ===== */

setInterval(async ()=>{
  await cfc_fetchXrpUsd();
  document.querySelectorAll(".live-nft-card").forEach(card=>{
    const el = card.querySelector(".live-nft-xrp");
    if(!el) return;
    const rl = Number(card.dataset.rlusd || 0);
    el.textContent = `${cfc_calcXrp(rl)} XRP`;
  });
}, 20000);
</script>
<script>
function switchView(which){
  // FORCE STATIC MARKET TO STAY HIDDEN
const staticMarket = document.getElementById("view-market");
if (staticMarket) staticMarket.style.display = "none";

  const market = document.getElementById('view-market')
  const purchases = document.getElementById('view-purchases')
  const redeem = document.getElementById('view-redeem')
  const liveMarket = document.getElementById('cfc-market-live')

  // Hide everything first
  if (market) market.style.display = 'none'
  if (purchases) purchases.style.display = 'none'
  if (redeem) redeem.style.display = 'none'
  if (liveMarket) liveMarket.style.display = 'none'

  // Show only what is needed
  if (which === 'market'){
   if (market) market.style.display = 'none'   // keep static NFTs hidden
    if (liveMarket) liveMarket.style.display = 'block'
  }

  if (which === 'purchases'){
    if (purchases) purchases.style.display = 'block'
  }

  if (which === 'redeem'){
    if (redeem) redeem.style.display = 'block'
  }
}

/* ========= NAV BUTTONS ========= */
document.addEventListener('DOMContentLoaded', () => {
  const navMarket = document.getElementById('navMarket')
  const navPurchases = document.getElementById('navPurchases')
  const navRedeem = document.getElementById('navRedeem')

  if (navMarket){
  navMarket.addEventListener('click', () => {
    // Go to market view (existing behavior)
    switchView('market');

    // RESET filter back to All (this is the missing part)
    try {
      activeCategory = "all";

      // Update tab highlight
      document.querySelectorAll("#cfc-category-tabs .btn").forEach(b => b.classList.remove("active"));
      const allBtn = document.querySelector('#cfc-category-tabs .btn[data-cat="all"]');
      if (allBtn) allBtn.classList.add("active");

      // Re-render the market grid
      if (typeof renderFilteredNFTs === "function") renderFilteredNFTs();
    } catch(e){}
  })
}


  if (navPurchases){
    navPurchases.addEventListener('click', async () => {
      switchView('purchases')
      if (typeof loadMyPurchases === 'function') {
        await loadMyPurchases()
      }
    })
  }

  if (navRedeem){
    navRedeem.addEventListener('click', () => {
      switchView('redeem')
    })
  }
})
</script>
<script>
async function loadMyPurchases() {
  const grid = document.getElementById('purchasesGrid')
  const noMsg = document.getElementById('noPurchasesMsg')

  if (!grid || !noMsg) return

 // Wallet not connected (only block on first load)
if (!window.connectedAccount) {
  if (!grid.innerHTML.trim()) {
    noMsg.textContent = 'Connect your wallet to see your purchases.'
    noMsg.style.display = 'block'
    grid.style.display = 'none'
  }
  return
}

  try {
    const resp = await fetch(
      `https://cfc-nft-shared-mint-backend.onrender.com/api/orders/by-wallet/${window.connectedAccount}`
    )

    const orders = await resp.json()

    // No purchases
    if (!orders.length) {
      noMsg.textContent = 'You don‚Äôt have any purchases yet.'
      noMsg.style.display = 'block'
      grid.style.display = 'none'
      return
    }

    // Has purchases
    noMsg.style.display = 'none'
    grid.style.display = 'grid'

    grid.innerHTML = orders.map(o => `
      <div class="card">
      <img class="nft-img" src="https://gateway.pinata.cloud/ipfs/${o.image_cid}" crossorigin="anonymous">
        <h3>${o.name}</h3>
        <div class="muted">Status: ${o.status}</div>

      <div class="action-buttons">
  <button class="btn claim"
   onclick="claimCfcReward(${o.submission_id})">
    Claim CFC Rewards
  </button>

  <button class="btn small"
    onclick="startRedeem(${o.id})">
    Redeem
  </button>

  ${o.content_cid ? `
  <button class="btn small open"
    onclick="openReader('${o.metadata_cid}', ${o.submission_id})">
    Open Content
  </button>
  ` : ""}

      </div>
    `).join('')

  } catch (e) {
    console.error(e)
    noMsg.textContent = 'Failed to load purchases.'
    noMsg.style.display = 'block'
    grid.style.display = 'none'
  }
}
</script>

<script>

function startRedeem(orderId){
  document.getElementById('redeemOrderId').value = orderId
  document.getElementById('redeemMsg').textContent = ''
  switchView('redeem')
}

async function submitRedeem(){
  const orderId = document.getElementById('redeemOrderId').value
  const email   = document.getElementById('redeemEmail').value
  const msg     = document.getElementById('redeemMsg')

  if (!orderId || !email){
    msg.textContent = 'Please enter your email.'
    return
  }

  try {
    const r = await fetch(
      'https://cfc-nft-shared-mint-backend.onrender.com/api/orders/redeem',
      {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          order_id: orderId,
          wallet: window.connectedAccount,
          email
        })
      }
    )

    const j = await r.json()

    if (!r.ok){
      msg.textContent = j.error || 'Redeem failed.'
      return
    }

    msg.textContent = '‚úÖ Redeem request submitted.'
  } catch (e){
    msg.textContent = 'Network error.'
  }
}
</script>
<script>
/* === CFC FIX: single wallet source for purchases (NO side effects) === */
window.getActiveWallet = function () {
  return (
    window.connectedAccount ||
    sessionStorage.getItem("connectedAccount") ||
    localStorage.getItem("xummAccount") ||
    localStorage.getItem("xrpl_account") ||
    ""
  );
};
</script>
<script>
  if (!window.connectedAccount) {
    const saved = sessionStorage.getItem('connectedAccount');
    if (saved) {
      window.connectedAccount = saved;
    }
  }
</script>

</body>
</html>
